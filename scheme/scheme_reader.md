这一部分是处理读取的。把读取到的字符串转化成Scheme内部使用的一套东东，类似于我们写的code最终都要被转化成二进制一样。这里也是一样的，一开始的输入肯定都是字符串的形式了，那这一部分的目的就是把比如`'2'`转化成数字2，原本就是字符串的还保持是字符串，把一条完整的Scheme命令转化成list数据结构，比如把`'(1 2)'`转化成Pair(1, Pair(2, nil))。

由于Scheme的命令都是递归的形式，所以对它的读取也是用递归来进行的，非常巧妙。只使用了两个函数，scheme_read和read_tail，这两个函数各自有对自己的递归调用，也有对彼此的调用，一个token过来，首先送给scheme_read，scheme_read能处理的就自己处理了，一旦遇到`(`，就吃掉它，然后把剩下的部分交给read_tail，read_tail负责把剩下的内容读完，直到匹配的`)`，因为命令中会有括号嵌套的情况，所以还会有对scheme_read的调用，然后scheme_read又会调用read_tail。。。。 嗯，这么想下去一定会疯的～～ CS61A中讲到，理解recursion的关键是要trust it，一条Scheme命令本质是一个Pair（当然，是一个非常复杂的Pair，嵌套了一层又一层），理解的关键是，不管那么多，只看最外面一层，一个Pair有两个元素，scheme_read负责读取第一个元素，read_tail负责读取第二个元素，然后用这两个元素组成一个Pair后返回即可。
